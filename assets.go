package assets

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/go-playground/bundler"
)

const (
	oldNewSeparator = " --> "
	manifestFile    = "/manifest.txt"
	cssHTMLTag      = "css_tag"
	jsHTMLTag       = "js_tag"
)

// RunMode is the type that determines which mode the template.FuncMap functions whould run in.
type RunMode int

// RunMode's
const (
	Development RunMode = iota
	Production
)

const (
	jsTag  = `<script type="text/javascript" src="%s"></script>`
	cssTag = `<link type="text/css" rel="stylesheet" href="%s">`
)

// Generate processes (bundles, compresses...) the assets for use and creates the Manifest file
// NOTE: no compression yet until there is a native and establishes compressor written in Go
func Generate(dirname string, leftDelim string, rightDelim string, ignoreRegexp *regexp.Regexp) ([]*bundler.ProcessedFile, string, error) {

	dirname = filepath.Clean(dirname)

	// verify dirname is actually a DIR + do symlink check
	fi, err := os.Lstat(dirname)
	if err != nil {
		return nil, "", err
	}

	if !fi.IsDir() {

		// check if symlink
		if fi.Mode()&os.ModeSymlink == os.ModeSymlink {

			link, err := filepath.EvalSymlinks(dirname)
			if err != nil {
				return nil, "", errors.New("Error Resolving Symlink:" + err.Error())
			}

			fi, err = os.Stat(link)
			if err != nil {
				return nil, "", err
			}

			if !fi.IsDir() {
				return nil, "", errors.New("dirname passed in is not a directory")
			}

			dirname = link

		} else {
			return nil, "", errors.New("dirname passed in is not a directory")
		}
	}

	processed, err := bundler.BundleDir(dirname, "", leftDelim, rightDelim, ignoreRegexp)
	if err != nil {
		return nil, "", err
	}

	var buff bytes.Buffer

	for _, file := range processed {
		buff.WriteString(filepath.FromSlash(file.OriginalFilename))
		buff.WriteString(oldNewSeparator)
		buff.WriteString(filepath.FromSlash(file.NewFilename))
		buff.WriteString("\n")
	}

	manifest := dirname + manifestFile

	if err = ioutil.WriteFile(manifest, buff.Bytes(), 0644); err != nil {
		return nil, "", err
	}

	return processed, manifest, nil
}

// LoadManifestFiles reads the manifest file generated by the Generate() command
// in Production mode and returns template.FuncMap for the provided RunMode
func LoadManifestFiles(dirname string, mode RunMode, leftDelim string, rightDelim string) (template.FuncMap, error) {

	mapped := map[string]string{}
	dirname = filepath.Clean(dirname) + string(os.PathSeparator)

	if mode == Production {
		f, err := os.Open(dirname + manifestFile)
		if err != nil {
			return nil, err
		}
		defer f.Close()

		mapped := map[string]string{}
		var files []string

		scanner := bufio.NewScanner(f)

		for scanner.Scan() {
			files = strings.SplitN(scanner.Text(), oldNewSeparator, 2)
			mapped[files[0]] = files[1]
		}
	}

	return loadMapFuncs(dirname, mode, leftDelim, rightDelim, mapped), nil
}

func loadMapFuncs(dirname string, mode RunMode, leftDelim string, rightDelim string, mapped map[string]string) template.FuncMap {

	funcs := template.FuncMap{}

	if mode == Production {
		funcs[cssHTMLTag] = createProdCSSTemplateFunc(mapped)
		funcs[jsHTMLTag] = createProdJSTemplateFunc(mapped)

		return funcs
	}

	funcs[cssHTMLTag] = createDevCSSTemplateFunc(dirname, leftDelim, rightDelim)
	funcs[jsHTMLTag] = createDevJSTemplateFunc(dirname, leftDelim, rightDelim)

	return funcs
}

func createProdCSSTemplateFunc(mapped map[string]string) interface{} {
	return func(name string) template.HTML {
		return template.HTML(fmt.Sprintf(cssTag, mapped[name]))
	}
}

func createProdJSTemplateFunc(mapped map[string]string) interface{} {
	return func(name string) template.HTML {
		return template.HTML(fmt.Sprintf(jsTag, mapped[name]))
	}
}

func createDevCSSTemplateFunc(dirname string, leftDelim string, rightDelim string) interface{} {
	// custom lexer, bytesBuffer

	return func(name string) template.HTML {
		buff := new(bytes.Buffer)

		files, err := loadFromDelims(dirname, name, leftDelim, rightDelim)
		if err != nil {
			panic(err)
		}

		for _, file := range files {
			buff.WriteString(fmt.Sprintf(cssTag, file))
		}

		buff.WriteString(fmt.Sprintf(cssTag, "/"+dirname+name))

		return template.HTML(buff.String())
	}
}

func createDevJSTemplateFunc(dirname string, leftDelim string, rightDelim string) interface{} {
	// custom lexer, bytesBuffer

	return func(name string) template.HTML {
		buff := new(bytes.Buffer)

		files, err := loadFromDelims(dirname, name, leftDelim, rightDelim)
		if err != nil {
			panic(err)
		}

		for _, file := range files {
			buff.WriteString(fmt.Sprintf(jsTag, file))
		}

		buff.WriteString(fmt.Sprintf(jsTag, "/"+dirname+name))

		return template.HTML(buff.String())
	}
}

func loadFromDelims(dirname string, name string, leftDelim string, rightDelim string) ([]string, error) {
	var err error
	var files []string
	var ok bool
	var path string

	existing := map[string]struct{}{}

	f, err := os.Open(dirname + name)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	l, err := bundler.NewLexer("assets-bundle", f, leftDelim, rightDelim)
	if err != nil {
		return nil, err
	}

LOOP:
	for {
		itm := l.NextItem()

		switch itm.Type {

		case bundler.ItemFile:

			path = filepath.FromSlash("/" + dirname + itm.Val)

			if _, ok = existing[path]; !ok {
				files = append(files, path)
				existing[path] = struct{}{}
			}

			fls, err := loadFromDelims(dirname, itm.Val, leftDelim, rightDelim)
			if err != nil {
				return nil, err
			}

			files = append(files, fls...)

		case bundler.ItemEOF:
			break LOOP
		case bundler.ItemError:
			return nil, errors.New(itm.Val)
		}
	}

	return files, nil
}
