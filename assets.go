package assets

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/go-playground/bundler"
)

const (
	oldNewSeparator = " --> "
	manifestFile    = "/manifest.txt"
)

// RunMode is the type that determines which mode the template.FuncMap functions whould run in.
type RunMode int

// RunMode's
const (
	Development RunMode = iota
	Production
)

const (
	jsTag  = `<script type="text/javascript" src="%s"></script>`
	cssTag = `<link type="text/css" rel="stylesheet" href="%s">`
)

// Generate processes (bundles, compresses...) the assets for use and creates the Manifest file
// NOTE: no compression yet until there is a native and establishes compressor written in Go
func Generate(dirname string, leftDelim string, rightDelim string, ignoreRegexp *regexp.Regexp) ([]*bundler.ProcessedFile, string, error) {

	dirname = filepath.Clean(dirname)

	// verify dirname is actually a DIR + do symlink check
	fi, err := os.Lstat(dirname)
	if err != nil {
		return nil, "", err
	}

	if !fi.IsDir() {

		// check if symlink
		if fi.Mode()&os.ModeSymlink == os.ModeSymlink {

			link, err := filepath.EvalSymlinks(dirname)
			if err != nil {
				return nil, "", errors.New("Error Resolving Symlink:" + err.Error())
			}

			fi, err = os.Stat(link)
			if err != nil {
				return nil, "", err
			}

			if !fi.IsDir() {
				return nil, "", errors.New("dirname passed in is not a directory")
			}

			dirname = link

		} else {
			return nil, "", errors.New("dirname passed in is not a directory")
		}
	}

	processed, err := bundler.BundleDir(dirname, "", leftDelim, rightDelim, ignoreRegexp)
	if err != nil {
		return nil, "", err
	}

	var buff bytes.Buffer

	for _, file := range processed {
		buff.WriteString(file.OriginalFilename)
		buff.WriteString(oldNewSeparator)
		buff.WriteString(file.NewFilename)
		buff.WriteString("\n")
	}

	manifest := dirname + manifestFile

	if err = ioutil.WriteFile(manifest, buff.Bytes(), 0644); err != nil {
		return nil, "", err
	}

	return processed, manifest, nil
}

// LoadManifestFiles reads the manifest file generated by the Generate() command
// this also loads the map and FuncMap into the Assets object, it only returns
// in case you wish to use use it on your own in some fashion i.e. static files....
// The recommended approach is just to use the returned template.FuncMap functions
// within your templates, check the error and discard the map
func LoadManifestFiles(dirname string, mode RunMode) (map[string]string, template.FuncMap, error) {

	dirname = filepath.Clean(dirname)

	f, err := os.Open(dirname + manifestFile)
	if err != nil {
		return nil, nil, err
	}

	mapped := map[string]string{}
	exts := map[string]struct{}{}
	var files []string

	scanner := bufio.NewScanner(f)

	for scanner.Scan() {
		files = strings.SplitN(scanner.Text(), oldNewSeparator, 2)
		mapped[files[0]] = files[1]
		exts[filepath.Ext(filepath.Base(files[0]))] = struct{}{}
	}

	return mapped, loadMapFuncs(mode, exts, mapped), nil
}

func loadMapFuncs(mode RunMode, exts map[string]struct{}, mapped map[string]string) template.FuncMap {

	funcs := template.FuncMap{}

	for ext := range exts {
		switch ext {
		case ".css":
			if mode == Production {
				funcs["css_tag"] = createProdCSSTemplateFunc(mapped)
				break
			}

			funcs["css_tag"] = createDevCSSTemplateFunc(mapped)
		case ".js":
			if mode == Production {
				funcs["js_tag"] = createProdJSTemplateFunc(mapped)
				break
			}

			funcs["js_tag"] = createDevJSTemplateFunc(mapped)
		}
	}

	return funcs
}

func createProdCSSTemplateFunc(mapped map[string]string) interface{} {
	return func(name string) template.HTML {
		return template.HTML(fmt.Sprintf(cssTag, mapped[name]))
	}
}

func createProdJSTemplateFunc(mapped map[string]string) interface{} {
	return func(name string) template.HTML {
		return template.HTML(fmt.Sprintf(jsTag, mapped[name]))
	}
}

func createDevCSSTemplateFunc(mapped map[string]string) interface{} {
	// custom lexer, bytesBuffer

	return nil
}

func createDevJSTemplateFunc(mapped map[string]string) interface{} {
	// custom lexer, bytesBuffer

	return nil
}
